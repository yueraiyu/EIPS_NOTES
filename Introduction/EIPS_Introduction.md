### 企业集成模式（EIP）

#### 一、简介

##### 1. 集成解决方案必须应对的挑战

* 网络不可用

  ```wiki
  * 不得不通过网络传输数据
  * single or distribute
  * 网络间传输数据时常延迟、阻塞
  ```

* 网络延迟

  ```wiki
  * 对比本地方法调用，通过网络传递数据更慢
  * 使用single app方法设计distribute app可能存在潜在的问题
  ```

* 不同的应用程序

  ```wiki
  * 系统间传输信息受编程语言、操作平台、数据格式影响
  * 集成方法需要接入不同技术
  ```

* 不可避免的改变

  ```wiki
  * 应用随时都在变化
  * 应用变化导致雪崩效应
  * 集成方案需要最小化依赖（系统间）、松散的连接（系统间）
  ```

##### 2. 通常的解决方法

* 文件传输

  ```wiki
  * 某些应用写文件，另外的应用读文件
  * 系统间需要就文件名、文件位置、文件格式、何时读写、谁可以删除达成共识
  ```

* 共享数据库

  ```wiki
  * 多个应用共享相同的数据库定义、共用一个物理数据库
  * 没有多个数据存储、系统间没有数据需要传输
  ```

* 远程(过程)调用

  ```wiki
  * 一个应用暴露一些能力，并由其它应用远程调用
  * 调用时实时、同步的
  ```

* 消息

  ```wiki
  * 某些应用发布消息到公共消息渠道
  * 其它应用从公共消息渠道读取消息（少量延迟）
  * 应用间必须就消息格式达成共识
  * 异步通信
  ```

  ```wiki
  * 通常应用（多个分布式应用的集合）需要集成多种方案，各系统根据自身特性选择最佳方案
  ```

##### 3. 什么是消息？

```wiki
* 电话系统
* 同步通信：呼叫方与接听方需要都在线

* 邮件系统
* 异步通信：发送方、接收方不必都在线
```

```wiki
* 允许高速、异步、程序到程序可靠的信息传输
* 程序间通过发送数据包（消息）通信
* 渠道（channel）
  > 可以视为队列，一种逻辑路由，连接应用、传输消息
  > 类似于集合/数组的能力，但是提供了多应用间的共享和消息使用
* sender and producer
  > sender，通过向渠道写入消息实现发送消息
  > producer, 通过读取（删除）渠道消息实现接收消息
* 消息本身是一个有序的数据结构，比如string、byte array、record、object
  > 可简单视为数据
  > 可视为即将在接收端执行的命令描述
  > 可视为发送端发生的事件
  > 消息包含两部分，header and body
  > header ：消息元信息，谁发的、发到哪里...消息系统使用，而消息使用方应用忽略
  > body ：需要传递的数据，消息系统忽略，而消息使用方使用
* 异步消息架构
```

##### 4. 什么是消息系统？

```wiki
* 消息能力
  > 由消息系统/面向消息中间件(MOM)提供 
* 消息系统管理消息
  > 与数据库管理数据持久化一样
* 系统管理员配置channels，构建应用间的通信，消息系统随后协调和管理消息的发送和接收，
  消息系统是以可靠的方式将消息由发送端搬运到接收端
* 邮件系统投递消息依赖于网络的可用性和应用的实际状态
* 消息系统需要克服邮件系统的约束，通过重复尝试直至消息发送成功，理想环境下一次成功，但是常常不理想
```

```wiki
* 消息投递的`五步`
  > create
    sender 创建消息并填充数据
  > send
    sender 添加消息到 channel
  > deliver
    消息系统将消息由 sender 的计算机移动到 receiver 的计算机，确保接收方可使用消息
  > receive
    receiver 从 channel 读取消息
  > process
    receiver 从消息中提取数据
```

![img](https://raw.githubusercontent.com/yueraiyu/note_imgs/master/md_imgs/msg_transmit.png)

```wiki
* send and forget
  > （step 2）发送应用发送消息到渠道后无需等待消息发送成功并被接收方接收到，完全信任消息系统
* store and forward
  > （step 2）发送应用将消息发送后，消息系统将消息存储于发送端的内存或者磁盘上；（step 3）而后消息系统
    将消息由发送端的计算机投递到接收端的计算机上并存储于接收端的计算机上，store and forward 可能会重复
    多次，直至接收端收到消息
```

```wiki
* create、send、receive、process步骤看书不必要的开销，为什么不简单的将消息投递给接收方？
  > 将数据包装为消息，交由消息系统存储，并委托消息系统投递数据
  > 数据被包装为原子消息，投递可以被重复投递，直至投递成功，接收方被确保能够获取到一份消息的副本
```

##### 5. 为什么使用消息系统？

```wiki
* 比`文件传输`直接
* 比`共享数据库`更好的封装性
* 比`远程调用`更可靠
```

```wiki
* 消息的益处
  > remote communication(远程通信)
    消息使分割的应用能够进行通信与数据传输，同一进程通过内存共享数据，而不同计算机间需要序列化同时通过网络发送。
    如果不需要远程通信，消息不是必须的，可以共享集合与内存。
    
  > platform/language integration(平台/语言集成)
  	多个计算机间进行远程通信受限于语言、技术、平台以及历史开发原因等因素。消息系统可以充当一个统一的传输器。
  	
  > asynchronous communication(异步通信)
  	消息支持`send and forget`的通信方式。发送者不必等待接收者接收消息或处理消息，甚至不需要确认消息系统投递消	 息，发送者只需要等待消息被发送(即消息被消息系统成功的存储于渠道)，而接收者的拉取于处理消息都是后台进行的。
  	如果接收者需要发送应答消息给发送者，则消息系统需要提供回调机制。
  
  > variable timing(可变时序)
  	同步通信，调用方必须等待接收方完成调用处理后同时返回结果，并确定是否继续，这需要保证被接收方能高效执行。
  	异步通信，允许调用方批量请求接收方，而接收方可以按照自己的节奏消费请求，这允许应用保存最大吞吐量的允许，
  	而不必浪费时间等待回应。
  
  > throttling(可调节)
    远程调用问题：1(receiver)...n(request)，可能导致过载，最终导致性能下降甚至崩溃
    异步通信：运行接收者调节消费速率，避免过载，同时不会导致请求方阻塞
  
  > reliable communication(通信可靠)
    消息提供了比远程调用更可靠的传输，消息使用 store and foward 传输消息，消息系统保证消息投递成功。
  
  > disconnected operation(失联操作)
    某些应用专门设计为网络断开仍可运行，当网络恢复后同步信息。消息系统将需要同步的消息进行队列化，等待
    其它应用重连后进行同步。
  
  > mediation(调度)
    消息系统在所有发送者与接收者之间作为调度器(GOF)，应用可将消息系统作为与其它应用或服务集成的目录。
    当应用丢失连接，只需要重连消息系统而不需要连接所有与消息系统相连的应用。
    消息系统可以充分使用多余资源提供高可用、负载均衡、失败重连、性能调节、质量调节。
  
  > thread management(线程管理)
    异步通信意味着应用不必阻塞等待其它应用回应。大量阻塞线程或者线程长时间阻塞，极易导致问题。
    大量阻塞线程使应用可用线程减少而导致应用无法工作。
    当应用崩溃，对于阻塞线程的状态极难恢复。
  
```

##### 6. 异步消息的挑战

```wiki
* 挑战
  异步消息并非完美无缺，它为不同系统集成提供了优雅的方案，但是也导致了新的挑战(异步模型、消息系统实现)。
  
  > complex programming model(复杂的编程模型)
    异步消息需要  event-driven 编程模型，业务逻辑与调用分离，逻辑被拆分为一系列依赖于输入消息的事件
    处理器。如此系统变得异常复杂，难以开发及调试，
    
  > sequence issue(序列问题)
    消息渠道保证消息投递，但是并不保证消息何时将被投递。
    可能导致顺序发送到消息系统的消息未被顺序投递。
  
  > synchronous scenarios(同步方案)
    并不是所有应用都能够在 send and forget 模式下操作(如：用户查询机票时，时希望马上看到机票的价格
    而不是一些不确定的时候才能看到)，消息系统需要弥合异步与同步的差距。
  
  > performance(性能)
    消息系统给通信增加了额外的开销(封装数据到消息并发送、接收消息并解析、不适用于大数据传输)。
    消息系统更适用于当初始数据备份后保存系统同步。
  
  > limited platform support(平台支持受限)
  
  > vendor lock-in(供应商锁定)
    协议互不支持。
```

##### 7. 关于异步的思考

![image-20221024183040329](https://raw.githubusercontent.com/yueraiyu/note_imgs/master/md_imgs/sync_or_async.png)

```wiki
* 同步
  > 同步必须等待调用回应。

* 异步
  > 不仅仅是单线程执行，可以多线程同时执行，从而提升性能(导致调试困难)
  > 结果依赖于回调机制，这依赖于调用方能够处理结果以及上下文的同步
  > 异步可按任意顺序执行，这意味着子线程相互独立没有任何顺序，同时调用方必须保证能够正确推导结果来自
    哪一个子线程并将各子线程的处理结果合并
```

##### 8. 分布式应用 VS 集成

```wiki
* 企业集成
  > 如何将所需应用集成并使它们同时运行
  
* 企业分布式应用
  > 企业应用通常包含多层架构(client/server具备多个确定版本的架构)，该架构使应用能够在分布的几个计算机上运行
  
* 为什么多层架构企业应用考虑分布式应用而不是应用集成？
  > 通信部分紧密耦合(彼此直接通信)，以至于各层无法独立运行
  > 各层间通信倾向于同步通信
  > 多层/原子应用倾向于快速响应用户使用
  
* 对比
  > 集成应用的各应用是相互独立的，可以单独运行，彼此通过松散的方式耦合
  > 集成各应用专注功能
  > 集成异步通信
  > 集成应用时间限制更宽松，各应用在结果可用前可以先处理其它事务，因此比用户需要等待实时结果的系统更能被接纳(耐心)
```

##### 9. 商业消息系统相关术语对照

![img](https://raw.githubusercontent.com/yueraiyu/note_imgs/master/md_imgs/eips_map.png)

